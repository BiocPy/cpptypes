#!/usr/bin/python3

# Parsing all of the C++ functions in the directory.
import os
import re

export_regex = re.compile("^// *\\[\\[export\\]\\]")
argname_regex = re.compile("\\s*,\\s*")

def parse_cpp_exports(srcdir : str):
    """Parse C++ source files for tagged exports.

    Args:
        srcdir (str): Path to a directory of C++ source files.

    Returns:
        Dict where keys are exported function names and values
        are a tuple of (return type, argument list).
    """
    all_functions = {}
    for p in os.listdir(srcdir):
        if not p.endswith(".cpp"):
            continue

        with open(os.path.join(srcdir, p), "r") as handle:
            capture = False
            combined = ""

            for line in handle:
                if export_regex.match(line):
                    capture = True
                    combined = "" 
                elif capture:
                    combined += line.strip()
                    if line.find("{") != -1:
                        first_bracket = combined.find("(")
                        first_space = combined.rfind(" ", 0, first_bracket)
                        restype = combined[:first_space].strip()
                        funname = combined[first_space + 1 : first_bracket].strip()

                        last_bracket = combined.rfind(")")
                        template_nesting = 0
                        last_arg = first_bracket
                        args = []
                        for i in range(first_bracket + 1, last_bracket):
                            if combined[i] == "<":
                                template_nesting += 1
                            elif combined[i] == ">":
                                template_nesting -= 1
                            elif combined[i] == ",":
                                if template_nesting == 0:
                                    curarg = combined[last_arg + 1 : i].strip()
                                    argname_start = max(curarg.rfind(" "), curarg.rfind("*"), curarg.rfind("&"))
                                    args.append((curarg[:argname_start].strip(), curarg[argname_start + 1:].strip()))
                                    last_arg = i

                        curarg = combined[last_arg + 1 : last_bracket].strip()
                        argname_start = max(curarg.rfind(" "), curarg.rfind("*"), curarg.rfind("&"))
                        args.append((curarg[:argname_start].strip(), curarg[argname_start + 1:].strip()))

                        all_functions[funname] = (restype, args)
                        capture = False

    return all_functions

def create_cpp_bindings(all_functions : dict, output_path: str):
    """Create the C++ bindings for exported functions.

    Args:
        all_functions (dict): Dictionary as produced by `parse_cpp_exports`.
        output_path (str): Path to store the output C++ bindings.

    Returns:
        A file is created at `output_path`. Nothing is returned.
    """

    all_function_names = list(all_functions.keys())
    all_function_names.sort()

    # Generating the C++ bindings for each function.
    with open(output_path, "w") as handle:
        handle.write("""/* DO NOT MODIFY: this is automatically generated by the ctypes-wrapper */

#include <cstring>
#include <stdexcept>

#ifdef _WIN32
#define PYAPI __declspec(dllexport)
#else
#define PYAPI
#endif

static char* copy_error_message(const char* original) {
    auto n = std::strlen(original);
    auto copy = new char[n + 1];
    std::strcpy(copy, original);
    return copy;
}""")

        externC = ["""PYAPI void free_error_message(char** msg) {
    delete [] *msg;
}"""]

        for k in all_function_names:
            restype, args = all_functions[k]

            types_only = [x[0] for x in args]
            handle.write("\n\n" + restype + " " + k + "(" + ", ".join(types_only) + ");")

            all_args = [x[0] + " " + x[1] for x in args]
            all_args.append("int* errcode")
            all_args.append("char** errmsg")

            names_only = [x[1] for x in args]
            if restype == "void":
                init_call = ""
                fun_call = k
                ret_call = ""
            else:
                init_call = "\n" + " " * 4 + restype + " output = "
                if restype.find("*") != -1:
                    init_call += "NULL;"
                else:
                    init_call += "0;"
                fun_call = "output = " + k
                ret_call = "\n" + " " * 4 + "return output;" 

            externC.append("PYAPI " + restype + " py_" + k + "(" + ", ".join(all_args) + ") {" + init_call + """
    try {
        """ + fun_call + "(" + ", ".join(names_only) + """);
    } catch(std::exception& e) {
        *errcode = 1;
        *errmsg = copy_error_message(e.what());
    } catch(...) {
        *errcode = 1;
        *errmsg = copy_error_message("unknown C++ exception");
    }""" + ret_call + """
}""")

        handle.write("\n\nextern \"C\" {")
        for cmd in externC:
            handle.write("\n\n" + cmd)
        handle.write("\n\n}\n")    

    return

# Generating the ctypes Python bindings for each function.
directly_usable = set([ "int", "char", "float", "double", "long", "short", "size_t", "ssize_t", "bool" ])
ll_regex = re.compile("^long\\s+long$")
ld_regex = re.compile("^long\\s+double$")
signed_char_regex = re.compile("^(un)?signed\\s+char$")
char_p_regex = re.compile("^char\\s*\*$")
const_regex = re.compile("^const\\s+")
signed_regex = re.compile("^signed\\s+")
unsigned_regex = re.compile("^unsigned\\s+")

def mapping(name, fun):
    if const_regex.match(name):
        name = name[6:].lstrip()

    # Simple numeric types.
    if name.endswith("_t") and (name.startswith("int") or name.startswith("uint")):
        return "ct.c_" + name[:-2]
    elif name in directly_usable:
        return "ct.c_" + name
    elif ll_regex.match(name):
        return "ct.c_longlong"
    elif ld_regex.match(name):
        return "ct.c_longdouble"

    # '(un)signed char' have different names.
    elif signed_char_regex.match(name):
        if name.startswith("unsigned"):
            return "ct.c_ubyte"
        elif name.startswith("signed"):
            return "ct.c_byte"

    # Pointer types.
    elif char_p_regex.match(name):
        return "ct.c_char_p"
    elif name.endswith("*") or name == "uintptr_t" or name == "intptr_t":
        return "ct.c_void_p"

    # Other signed/unsigned versions of non-pointer types.
    elif signed_regex.match(name):
        return mapping(name[7:].lstrip(), fun)
    elif unsigned_regex.match(name):
        return mapping(name[9:].lstrip(), fun)

    raise ValueError("don't yet know how to deal with '" + name + "' for function '" + fun + "'") 

def create_py_bindings(all_functions : dict, output_path: str, dll_prefix: str):
    """Create the Python bindings for exported functions.

    Args:
        all_functions (dict): Dictionary as produced by `parse_cpp_exports`.
        output_path (str): Path to store the output Python bindings.
        dll_prefix (str): Prefix of the DLL for the compiled C++ code. 

    Returns:
        A file is created at `output_path`. Nothing is returned.
    """

    all_function_names = list(all_functions.keys())
    all_function_names.sort()

    with open(output_path, "w") as handle:
        handle.write("""# DO NOT MODIFY: this is automatically generated by the ctypes-wrapper

import os
import ctypes as ct

def catch_errors(f):
    def wrapper(*args):
        errcode = ct.c_int(0)
        errmsg = ct.c_char_p(0)
        output = f(*args, ct.byref(errcode), ct.byref(errmsg))
        if errcode.value != 0:
            msg = errmsg.value.decode('ascii')
            lib.free_error_message(errmsg)
            raise RuntimeError(msg)
        return output
    return wrapper

# TODO: surely there's a better way than whatever this is.
dirname = os.path.dirname(os.path.abspath(__file__))
contents = os.listdir(dirname)
lib = None
for x in contents:
    if x.startswith('""" + dll_prefix + """') and not x.endswith("py"):
        lib = ct.CDLL(os.path.join(dirname, x))
        break

if lib is None:
    raise ImportError("failed to find the """ + dll_prefix + """.* module")

lib.free_error_message.argtypes = [ ct.POINTER(ct.c_char_p) ]""")

        for k in all_function_names:
            restype, args = all_functions[k]
            if restype != "void":
                handle.write("\n\nlib.py_" + k + ".restype = " + mapping(restype, k) + "\n")
            else:
                handle.write("\n\n")
            argtypes = [mapping(x[0], k) for x in args]
            argtypes.append("ct.POINTER(ct.c_int)")
            argtypes.append("ct.POINTER(ct.c_char_p)")
            handle.write("lib.py_" + k + ".argtypes = [\n    " + ",\n    ".join(argtypes) + "\n]")

        for k in all_function_names:
            restype, args = all_functions[k]
            argnames = [x[1] for x in args]
            handle.write("\n\ndef " + k + "(" + ", ".join(argnames) + """):
    return catch_errors(lib.py_""" + k + ")(" + ", ".join(argnames) + """)""")

    return

if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(
        prog='Create ctypes wrappers',
        description="""
    This script runs through a directory of C++ source files and pulls out all
    function definitions marked with an `// [[export]]` header. It then creates
    wrapper files in C++ and Python to bind the exported functions with correct
    types and exception handling. This mimics the behavior of `Rcpp::compile()`,
    which does the same thing for C++ bindings in R packages.""")

    parser.add_argument("srcdir", type=str, help="Source directory for the C++ files.")
    parser.add_argument("--py", dest="pypath", type=str, default="ctypes_bindings.py", help="Output path for the Python-side bindings.")
    parser.add_argument("--cpp", dest="cpppath", type=str, default="ctypes_bindings.cpp", help="Output path for the C++-side bindings.")
    parser.add_argument("--dll", dest="dllname", type=str, default="core", help="Prefix of the DLL.")
    cmd_args = parser.parse_args()

    all_functions = parse_cpp_exports(cmd_args.srcdir)
    create_cpp_bindings(all_functions, cmd_args.cpppath)
    create_py_bindings(all_functions, cmd_args.pypath, cmd_args.dllname)
