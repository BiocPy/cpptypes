#!/usr/bin/python3

import argparse
parser = argparse.ArgumentParser(
    prog='Create ctypes wrappers',
    description="""
This script runs through a directory of C++ source files and pulls out all
function definitions marked with an `// [[export]]` header. It then creates
wrapper files in C++ and Python to bind the exported functions with correct
types and exception handling. This mimics the behavior of `Rcpp::compile()`,
which does the same thing for C++ bindings in R packages.""")

parser.add_argument("srcdir", type=str, help="Source directory for the C++ files.")
parser.add_argument("--py", dest="pypath", type=str, default="ctypes_bindings.py", help="Output path for the Python-side bindings.")
parser.add_argument("--cpp", dest="cpppath", type=str, default="ctypes_bindings.cpp", help="Output path for the C++-side bindings.")
parser.add_argument("--dll", dest="dllname", type=str, default="core", help="Prefix of the DLL.")
cmd_args = parser.parse_args()

# Parsing all of the C++ functions in the directory.
import os
import re
export_regex = re.compile("^// *\\[\\[export\\]\\]")
argname_regex = re.compile("\\s*,\\s*")

all_functions = {}
for p in os.listdir(cmd_args.srcdir):
    if not p.endswith(".cpp"):
        continue

    with open(os.path.join(cmd_args.srcdir, p), "r") as handle:
        capture = False
        combined = ""

        for line in handle:
            if export_regex.match(line):
                capture = True
                combined = "" 
            elif capture:
                combined += line.strip()
                if line.find("{") != -1:
                    first_space = combined.find(" ")
                    restype = combined[:first_space].strip()

                    first_bracket = combined.find("(")
                    funname = combined[first_space + 1 : first_bracket].strip()

                    last_bracket = combined.rfind(")")
                    template_nesting = 0
                    last_arg = first_bracket
                    args = []
                    for i in range(first_bracket + 1, last_bracket):
                        if combined[i] == "<":
                            template_nesting += 1
                        elif combined[i] == ">":
                            template_nesting -= 1
                        elif combined[i] == ",":
                            if template_nesting == 0:
                                curarg = combined[last_arg + 1 : i].strip()
                                argname_start = max(curarg.rfind(" "), curarg.rfind("*"), curarg.rfind("&"))
                                args.append((curarg[:argname_start].strip(), curarg[argname_start + 1:].strip()))
                                last_arg = i

                    curarg = combined[last_arg + 1 : last_bracket].strip()
                    argname_start = max(curarg.rfind(" "), curarg.rfind("*"), curarg.rfind("&"))
                    args.append((curarg[:argname_start].strip(), curarg[argname_start + 1:].strip()))

                    all_functions[funname] = (restype, args)
                    capture = False

# Generating the C++ bindings for each function.
with open(cmd_args.cpppath, "w") as handle:
    handle.write("""/* DO NOT MODIFY: this is automatically generated by the ctypes-compiler */

#include <cstring>
#include <stdexcept>

#ifdef _WIN32
#define PYAPI __declspec(dllexport)
#else
#define PYAPI
#endif

static char* copy_error_message(const char* original) {
    auto n = std::strlen(original);
    auto copy = new char[n + 1];
    std::strcpy(copy, original);
    return copy;
}""")

    externC = ["""PYAPI void free_error_message(char** msg) {
    delete [] *msg;
}"""]

    for k in all_functions.keys():
        restype, args = all_functions[k]

        types_only = [x[0] for x in args]
        handle.write("\n\n" + restype + " " + k + "(" + ", ".join(types_only) + ");")

        all_args = [x[0] + " " + x[1] for x in args]
        all_args.append("int* errcode")
        all_args.append("char** errmsg")

        names_only = [x[1] for x in args]
        if restype == "void":
            init_call = ""
            fun_call = k
            ret_call = ""
        else:
            init_call = "\n" + " " * 4 + restype + " output;"
            fun_call = "output = " + k
            ret_call = "\n" + " " * 4 + "return output;" 

        externC.append("PYAPI " + restype + " py_" + k + "(" + ", ".join(all_args) + ") {" + init_call + """
    try {
        """ + fun_call + "(" + ", ".join(names_only) + """);
    } catch(std::exception& e) {
        *errcode = 1;
        *errmsg = copy_error_message(e.what());
    } catch(...) {
        *errcode = 1;
        *errmsg = copy_error_message("unknown C++ exception");
    }""" + ret_call + """
}""")

    handle.write("\n\nextern \"C\" {")
    for cmd in externC:
        handle.write("\n\n" + cmd)
    handle.write("\n\n}\n")    

# Generating the ctypes Python bindings for each function.
char_regex = re.compile("char *\*")
def mapping(name):
    if char_regex.match(name):
        return "ct.c_char_p"
    if name.endswith("*") or name == "uintptr_t" or name == "intptr_t":
        return "ct.c_void_p"
    elif name.endswith("_t") and (name.startswith("int") or name.startswith("uint")):
        return "ct.c_" + name[:-2]
    elif name == "int" or name == "char" or name == "double" or name == "float":
        return "ct.c_" + name
    else:
        raise ValueError("don't yet know how to deal with '" + name + "'") 
    
with open(cmd_args.pypath, "w") as handle:
    handle.write("""# DO NOT MODIFY: this is automatically generated by the ctypes-compiler

import os
import ctypes as ct

# TODO: surely there's a better way than whatever this is.
dirname = os.path.dirname(os.path.abspath(__file__))
contents = os.listdir(dirname)
lib = None
for x in contents:
    if x.startswith('""" + cmd_args.dllname + """') and not x.endswith("py"):
        lib = ct.CDLL(os.path.join(dirname, x))

if lib is None:
    raise ImportError("failed to find the """ + cmd_args.dllname + """.* module")

lib.free_error_message.argtypes = [ ct.POINTER(ct.c_char_p) ]""")

    for k in all_functions.keys():
        restype, args = all_functions[k]
        if restype != "void":
            handle.write("\n\nlib.py_" + k + ".restype = " + mapping(restype) + "\n")
        else:
            handle.write("\n\n")
        argtypes = [mapping(x[0]) for x in args]
        argtypes.append("ct.POINTER(ct.c_int)")
        argtypes.append("ct.POINTER(ct.c_char_p)")
        handle.write("lib.py_" + k + ".argtypes = [\n    " + ",\n    ".join(argtypes) + "\n]")

    for k in all_functions.keys():
        restype, args = all_functions[k]
        argnames = [x[1] for x in args]
        handle.write("\n\ndef " + k + "(" + ", ".join(argnames) + """):
    errcode___ = ct.c_int(0)
    errmsg___ = ct.c_char_p(0)
    output___ = lib.py_""" + k + "(" + ", ".join(argnames) + """, ct.byref(errcode___), ct.byref(errmsg___))
    if errcode___.value != 0:
        msg = errmsg___.value.decode('ascii')
        lib.free_error_message(errmsg___)
        raise RuntimeError(msg)
    return output___""")
